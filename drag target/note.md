在这一次实验中，为了获取鼠标的坐标，找到了两个和鼠标坐标的api,分别是``screenX(Y)``,``clientX(Y)``,经过进一步的使用，发现``clientX(Y)``才是我想要的，它获得的时相对于浏览器客户端的坐标，而另外一个是相对于用户屏幕的坐标，想想某个用户心血来潮，把浏览器缩小来使用，这样的话，使用``screenX(Y)``就可能导致拖动后进行拖动前后坐标之差不符合实际了，所以一定要使用``clientX(Y)``

---
## drag_1.html

这是一个自己写的一个例子，这个例子有一个缺点，那就是，当在元素范围内点击后，元素移动时元素的左上角总是和鼠标位置一致的，而且第一个``addEventListener``内嵌套的第一个``addEventListener``是挂在document上的，如果也是挂在dbox上，那么当鼠标想向上向左移动时，由于此时元素移动时元素的左上角总是和鼠标位置一致，所以鼠标就会移出元素范围，自然不能触发mousemove事件，总而言之这个实验也并不算完美。


## drag_2.html

这是MDZ上的一个例子，仅供参考。


## drag_3.html

这个例子的效果比第一次好多了，效果很好。这个例子好像在Stackoverflow内看到过。

补充点东西：这个例子并没有为 div 设置``draggable``属性 ,而是采用设置``class="draggable"``，另外这个匿名函数里面声名了一个 Object 对象，然后给 Object 赋予一个 addlistener 属性来挂上匿名函数，而且该匿名函数是个“立刻执行函数”，立刻执行之后返回一个 dragdrop，也就是前面定义的 Object 对象！然后通过``DragDrop.addlistener();`` 这一句来执行添加监听器的步骤。

这样写的好处是不用再为每一个具体的而且有``class="draggable"``的 div 添加监听器！

进一步修改可以更加抽象化，那样就可以达到复用的目的了。
